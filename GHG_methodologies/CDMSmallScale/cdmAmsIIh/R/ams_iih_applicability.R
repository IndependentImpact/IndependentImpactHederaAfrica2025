#' Check AMS-II.H centralization scope applicability
#'
#' AMS-II.H requires that the project centralizes the provision of utilities that
#' were previously generated by multiple decentralized units. This helper
#' verifies that each utility service included in the baseline is represented in
#' the project inventory and that the number of centralized units does not exceed
#' one per service. It also ensures that centralization actually reduces the
#' number of generating units relative to the baseline.
#'
#' @param baseline_summary Tibble describing the decentralized baseline system.
#' @param project_summary Tibble describing the centralized project system.
#' @param utility_col Column identifying the utility service (for example
#'   "steam" or "chilled_water").
#' @param baseline_unit_col Column storing the number of decentralized units in
#'   the baseline.
#' @param project_unit_col Column storing the number of centralized units in the
#'   project scenario.
#' @return Logical scalar indicating whether the applicability criterion is met.
#' @examples
#' baseline <- tibble::tibble(
#'   utility_service = c("steam", "hot_water"),
#'   baseline_unit_count = c(4, 3)
#' )
#' project <- tibble::tibble(
#'   utility_service = c("steam", "hot_water"),
#'   project_unit_count = c(1, 1)
#' )
#' check_applicability_centralization_scope_iih(baseline, project)
#' @export
check_applicability_centralization_scope_iih <- function(baseline_summary,
                                                         project_summary,
                                                         utility_col = "utility_service",
                                                         baseline_unit_col = "baseline_unit_count",
                                                         project_unit_col = "project_unit_count") {
  baseline_tbl <- tibble::as_tibble(baseline_summary)
  project_tbl <- tibble::as_tibble(project_summary)

  utility_sym <- rlang::ensym(utility_col)
  baseline_units_sym <- rlang::ensym(baseline_unit_col)
  project_units_sym <- rlang::ensym(project_unit_col)

  missing_baseline <- setdiff(c(rlang::as_string(utility_sym), rlang::as_string(baseline_units_sym)), names(baseline_tbl))
  missing_project <- setdiff(c(rlang::as_string(utility_sym), rlang::as_string(project_units_sym)), names(project_tbl))
  if (length(missing_baseline) > 0 || length(missing_project) > 0) {
    stop("Input tables must contain the requested columns.", call. = FALSE)
  }

  joined <- baseline_tbl |>
    dplyr::inner_join(project_tbl, by = rlang::as_string(utility_sym))

  if (nrow(joined) == 0 || nrow(joined) != nrow(baseline_tbl)) {
    return(FALSE)
  }

  all(
    joined[[rlang::as_string(project_units_sym)]] <= 1 &
      joined[[rlang::as_string(baseline_units_sym)]] >= joined[[rlang::as_string(project_units_sym)]] &
      joined[[rlang::as_string(baseline_units_sym)]] > joined[[rlang::as_string(project_units_sym)]]
  )
}

#' Check AMS-II.H monitoring completeness
#'
#' AMS-II.H requires that baseline and project monitoring datasets contain the
#' fuel use, emission factor, and (when relevant) useful output data needed to
#' compute specific energy consumption. This helper checks that the specified
#' columns exist and do not contain missing values.
#'
#' @param monitoring_data Tibble containing combined baseline and project
#'   monitoring data.
#' @param required_cols Character vector of columns that must exist with no
#'   missing values.
#' @return Logical scalar indicating whether all required columns are present and
#'   populated.
#' @examples
#' monitoring <- tibble::tibble(
#'   baseline_fuel_use_gj = 4200,
#'   baseline_emission_factor_tco2_per_gj = 0.071,
#'   baseline_useful_output_gj = 3600,
#'   project_fuel_use_gj = 3000,
#'   project_emission_factor_tco2_per_gj = 0.068,
#'   project_useful_output_gj = 2880
#' )
#' check_applicability_monitoring_iih(monitoring)
#' @export
check_applicability_monitoring_iih <- function(monitoring_data,
                                               required_cols = c(
                                                 "baseline_fuel_use_gj",
                                                 "baseline_emission_factor_tco2_per_gj",
                                                 "project_fuel_use_gj",
                                                 "project_emission_factor_tco2_per_gj"
                                               )) {
  data_tbl <- tibble::as_tibble(monitoring_data)
  missing_cols <- setdiff(required_cols, names(data_tbl))
  if (length(missing_cols) > 0) {
    stop("Monitoring data is missing required columns: ", paste(missing_cols, collapse = ", "), call. = FALSE)
  }

  required_complete <- data_tbl |>
    dplyr::select(dplyr::all_of(required_cols))

  all(stats::complete.cases(required_complete))
}

#' Check AMS-II.H efficiency improvement
#'
#' Centralization must deliver energy efficiency gains relative to the
#' decentralized baseline. This helper compares the specific energy consumption
#' (fuel per useful output) before and after the project and verifies that the
#' relative improvement meets or exceeds a user-provided threshold.
#'
#' @param baseline_data Tibble containing baseline monitoring data.
#' @param project_data Tibble containing project monitoring data.
#' @param group_cols Optional character vector of grouping columns shared across
#'   the datasets.
#' @param baseline_fuel_col Column storing baseline fuel use (GJ).
#' @param baseline_output_col Column storing baseline useful output (GJ).
#' @param project_fuel_col Column storing project fuel use (GJ).
#' @param project_output_col Column storing project useful output (GJ).
#' @param minimum_improvement Minimum fractional improvement (between 0 and 1)
#'   required for applicability. A value of `0.05` corresponds to a 5% reduction
#'   in specific energy consumption.
#' @return Logical scalar indicating whether the efficiency improvement criterion
#'   is met across all groups.
#' @examples
#' baseline <- tibble::tibble(
#'   facility = c("A", "B"),
#'   baseline_fuel_use_gj = c(4200, 3150),
#'   baseline_useful_output_gj = c(3600, 2700)
#' )
#' project <- tibble::tibble(
#'   facility = c("A", "B"),
#'   project_fuel_use_gj = c(3000, 2250),
#'   project_useful_output_gj = c(2880, 2160)
#' )
#' check_applicability_efficiency_improvement_iih(
#'   baseline,
#'   project,
#'   group_cols = "facility",
#'   minimum_improvement = 0.05
#' )
#' @export
check_applicability_efficiency_improvement_iih <- function(baseline_data,
                                                           project_data,
                                                           group_cols = NULL,
                                                           baseline_fuel_col = "baseline_fuel_use_gj",
                                                           baseline_output_col = "baseline_useful_output_gj",
                                                           project_fuel_col = "project_fuel_use_gj",
                                                           project_output_col = "project_useful_output_gj",
                                                           minimum_improvement = 0.05) {
  if (minimum_improvement < 0 || minimum_improvement > 1) {
    stop("`minimum_improvement` must be between 0 and 1.", call. = FALSE)
  }

  baseline_tbl <- tibble::as_tibble(baseline_data)
  project_tbl <- tibble::as_tibble(project_data)

  baseline_fuel_sym <- rlang::ensym(baseline_fuel_col)
  baseline_output_sym <- rlang::ensym(baseline_output_col)
  project_fuel_sym <- rlang::ensym(project_fuel_col)
  project_output_sym <- rlang::ensym(project_output_col)

  join_cols <- if (is.null(group_cols) || length(group_cols) == 0) character() else group_cols

  summarise_specific <- function(tbl, fuel_sym, output_sym) {
    aggregator <- function(data) {
      group_vars <- dplyr::group_vars(data)

      totals <- data |>
        dplyr::summarise(
          .fuel = sum(dplyr::coalesce(!!fuel_sym, 0), na.rm = TRUE),
          .output = sum(dplyr::coalesce(!!output_sym, 0), na.rm = TRUE),
          .groups = "drop"
        ) |>
        dplyr::mutate(
          specific = ifelse(.output > 0, .fuel / .output, NA_real_)
        )

      if (length(group_vars) == 0) {
        dplyr::select(totals, specific)
      } else {
        totals |>
          dplyr::select(dplyr::all_of(group_vars), specific)
      }
    }

    if (length(join_cols) == 0) {
      aggregator(tibble::as_tibble(tbl))
    } else {
      tibble::as_tibble(tbl) |>
        dplyr::group_by(dplyr::across(dplyr::all_of(join_cols))) |>
        aggregator()
    }
  }

  baseline_specific <- summarise_specific(baseline_tbl, baseline_fuel_sym, baseline_output_sym)
  project_specific <- summarise_specific(project_tbl, project_fuel_sym, project_output_sym)

  combined <- if (length(join_cols) == 0) {
    dplyr::bind_cols(
      baseline_specific |> dplyr::rename(specific_baseline = specific),
      project_specific |> dplyr::rename(specific_project = specific)
    )
  } else {
    baseline_specific |>
      dplyr::rename(specific_baseline = specific) |>
      dplyr::left_join(
        project_specific |>
          dplyr::rename(specific_project = specific),
        by = join_cols
      )
  }

  baseline_vals <- combined$specific_baseline
  project_vals <- combined$specific_project

  if (length(baseline_vals) == 0) {
    return(FALSE)
  }

  all_improvements <- !is.na(baseline_vals) & !is.na(project_vals) &
    baseline_vals > 0 &
    project_vals <= baseline_vals * (1 - minimum_improvement)

  all(all_improvements)
}
